<!doctype html>
<html>
<head>
<title>HTMLElement</title>
<script>

// This needs to run first so that it can catch reported errors before Mocha's
// global error handler does.
window.catchReportedErrors = (() => {
  let currentHandler = undefined;

  window.addEventListener('error', e => {
    if (currentHandler) currentHandler(e);
  }, true);

  return (fn, handler) => {
    currentHandler = handler;
    fn();
    currentHandler = undefined;
  };
})();

</script>
<script>
  (window.customElements = window.customElements || {}).forcePolyfill = true;
</script>
<script src="../../../node_modules/es6-promise/dist/es6-promise.auto.min.js"></script>
<script src="../../../node_modules/wct-browser-legacy/browser.js"></script>
<script src="../../../custom-elements.min.js"></script>
</head>
<body>

<script>
function generateLocalName() {
  return 'test-element-' + Math.random().toString(32).substring(2);
}

function defineWithLocalName(localName) {
  const constructor = class extends HTMLElement {
    constructor() {
      super();
      this.constructed = true;
      this.connectedCallbackCount = 0;
      this.disconnectedCallbackCount = 0;
    }

    connectedCallback() {
      this.connectedCallbackCount++;
    }

    disconnectedCallback() {
      this.disconnectedCallbackCount++;
    }
  }
  
  customElements.define(localName, constructor);

  return constructor;
}

suite('Constructing elements', function() {
  let localName;
  let constructor;

  setup(function() {
    localName = generateLocalName();
    constructor = defineWithLocalName(localName);
  });

  test('Custom elements can be constructed from their constructor.', function() {
    const element = new constructor();

    assert(element instanceof constructor);
    assert(element instanceof HTMLElement);
    // The native `Element` function is not replaced, only patched; check that the
    // prototype chain is correctly connected.
    assert(element instanceof Element);
    assert.equal(element.localName, localName);
  });

  test('Custom element constructors must be given to `customElements.define` ' +
    'to be constructed.', function() {
      class CustomElement extends HTMLElement {}

      assert.throws(function() {
        new CustomElement();
      });
    });

  test('Non-conformant custom element constructors that attempt to construct ' +
    'more instances of themselves using `new` before calling into ' +
    '`HTMLElement` (e.g. via `super()`) cause an error to be thrown when the ' +
    '`HTMLElement` constructor finds the AlreadyConstructedMarker.',
    function() {
      let createSelf = true;
      class NonConformantCustomElement1 extends HTMLElement {
        constructor() {
          if (createSelf) {
            createSelf = false;
            new NonConformantCustomElement1();
          }

          super();
        }
      }
      customElements.define('unconstructable-custom-element-1',
          NonConformantCustomElement1);

      assert.doesNotThrow(function() {
        createSelf = true;
        document.createElement('unconstructable-custom-element-1');
      });

      assert.doesNotThrow(function() {
        createSelf = true;
        new NonConformantCustomElement1();
      });
    });

  test('Non-conformant custom element constructors that attempt to create ' +
    'more instances of themselves using `Document#createElement` before ' +
    'calling into `HTMLElement` (e.g. via `super()`) do NOT cause an error ' +
    'to be thrown.', function() {
      let createSelf = true;
      class NonConformantCustomElement2 extends HTMLElement {
        constructor() {
          if (createSelf) {
            createSelf = false;
            document.createElement('non-conformant-custom-element-2');
          }

          super();
        }
      }
      customElements.define('non-conformant-custom-element-2',
          NonConformantCustomElement2);

      assert.doesNotThrow(function() {
        createSelf = true;
        document.createElement('non-conformant-custom-element-2');
      });

      assert.doesNotThrow(function() {
        createSelf = true;
        new NonConformantCustomElement2();
      });
    });

  test('Non-conformant custom element constructor that returns a different ' +
    'element causes an error to be thrown.', function() {
      class NonConformantCustomElement3 extends HTMLElement {
        constructor() {
          return document.createElement('div');
        }
      }
      customElements.define('non-conformant-custom-element-3',
          NonConformantCustomElement3);

      const errors = [];
      catchReportedErrors(() => {
        assert.doesNotThrow(function() {
          document.createElement('non-conformant-custom-element-3');
        });
      }, (e) => {
        e.preventDefault();
        e.stopImmediatePropagation();
        errors.push(e);
      });
      assert.equal(errors.length, 1);

      assert.doesNotThrow(function() {
        new NonConformantCustomElement3();
      });
    });
});
</script>
</body>
</html>
