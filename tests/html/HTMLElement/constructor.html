<!doctype html>
<html>
<head>
<title>HTMLElement</title>
<script>
  (window.customElements = window.customElements || {}).forcePolyfill = true;
</script>
<script src="../../../node_modules/es6-promise/dist/es6-promise.auto.min.js"></script>
<script src="../../../node_modules/wct-browser-legacy/browser.js"></script>
<script src="../../../custom-elements.min.js"></script>
<script src="../../PatchMonitor.js"></script>
<script>
  PatchMonitor.wrap([
    Document.prototype,
    DocumentFragment.prototype,
    Element.prototype,
    HTMLElement.prototype,
    HTMLLinkElement.prototype,
    window.HTMLTemplateElement ? window.HTMLTemplateElement.prototype : undefined,
    MutationObserver.prototype,
    MutationRecord.prototype,
    Node.prototype,
  ]);
</script>
</head>
<body>

<script>
function generateLocalName() {
  return 'test-element-' + Math.random().toString(32).substring(2);
}

function defineWithLocalName(localName) {
  const constructor = class extends HTMLElement {
    constructor() {
      super();
      this.constructed = true;
      this.connectedCallbackCount = 0;
      this.disconnectedCallbackCount = 0;
    }

    connectedCallback() {
      this.connectedCallbackCount++;
    }

    disconnectedCallback() {
      this.disconnectedCallbackCount++;
    }
  }
  
  customElements.define(localName, constructor);

  return constructor;
}

suite('Constructing elements', function() {
  let localName;
  let constructor;

  setup(function() {
    localName = generateLocalName();
    constructor = defineWithLocalName(localName);
  });

  test('Custom elements can be constructed from their constructor.', function() {
    PatchMonitor.runGuarded(function() {
      const element = new constructor();

      assert(element instanceof constructor);
      assert(element instanceof HTMLElement);
      // The native `Element` function is not replaced, only patched; check that the
      // prototype chain is correctly connected.
      assert(element instanceof Element);
      assert.equal(element.localName, localName);
    });
  });

  test('Custom element constructors must be given to `customElements.define` ' +
    'to be constructed.', function() {
      PatchMonitor.runGuarded(function() {
        class CustomElement extends HTMLElement {}

        assert.throws(function() {
          new CustomElement();
        });
      });
    });

  test('Custom element constructors may not cause more instances of the same ' +
    'custom element to be created before calling into `HTMLElement` (e.g. via ' +
    '`super()`).', function() {
      // This test is not wrapped in a call to `PatchMonitor.runGuarded` so that the
      // constructor can (invalidly) call `document.createElement`.

      const element = document.createElement('bad-custom-element-1');
      document.body.appendChild(element);

      assert.throws(function() {
        let createSelf = true;
        customElements.define('bad-custom-element-1', class extends HTMLElement {
          constructor() {
            if (createSelf) {
              createSelf = false;
              document.createElement('bad-custom-element-1');
            }
            super();
          }
        });
      });

      document.body.removeChild(element);
    });
});
</script>
</body>
</html>
